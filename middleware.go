package gojwt

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/square/go-jose/v3"
	"github.com/square/go-jose/v3/jwt"
)

//JWTResolver takes the values from a http request and returns either the JWTinfo or a error
type JWTResolver func(w http.ResponseWriter, r *http.Request) (JWTInfo, error)

//JWTInfo is used to store JWKs and issuers in context
type JWTInfo struct {
	JWKS   *jose.JSONWebKeySet
	Issuer string
}

//JWTMiddleware is used to mange JWT middleware
type JWTMiddleware struct {
	JWTResolver JWTResolver
}

//NewStaticJWTResolver pass static jwt info throught the JWT resolver
func NewStaticJWTResolver(info JWTInfo) func(w http.ResponseWriter, r *http.Request) (JWTInfo, error) {
	return func(w http.ResponseWriter, r *http.Request) (JWTInfo, error) {
		return info, nil
	}
}

//AddJWTInfo is the first middleware required to use this middleware chain, it adds a JWTInfo instance to the context for use in following requests
func (mid *JWTMiddleware) AddJWTInfo(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		jwtInfo, err := mid.JWTResolver(w, r)
		if err != nil {
			ctx := context.WithValue(r.Context(), ContextJWTResolverError, err)

			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		ctx := context.WithValue(r.Context(), ContextJWTInfo, &jwtInfo)
		next.ServeHTTP(w, r.WithContext(ctx))
		return
	})
}

//Verifier validtes every request to test if it matches the provided JWKs
func (mid *JWTMiddleware) Verifier(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		jwtInfo, err := GetJWTInfoFromContext(r.Context())
		if err != nil {
			next.ServeHTTP(w, r)
			return
		}

		bearerHeaderRaw := r.Header.Get("Authorization")
		bearerHeader := strings.Replace(bearerHeaderRaw, "Bearer ", "", -1)

		tok, err := jwt.ParseSigned(bearerHeader)

		if err != nil {
			ctx := context.WithValue(r.Context(), ContextJWTError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		var claims *jwt.Claims
		for _, jwk := range jwtInfo.JWKS.Keys {
			err = tok.Claims(jwk, &claims)

			if err == nil {
				break
			}
		}

		if claims == nil {
			ctx := context.WithValue(r.Context(), ContextJWTError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		ctx := context.WithValue(r.Context(), ContextJWTObject, tok)
		ctx = context.WithValue(r.Context(), ContextJWTClaims, claims)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

//ClaimsValidator will read claim values from context and validate, this includes ISS, EXP, NBF. if any validations fail a error will be logged under ContextValidatorError
func (mid *JWTMiddleware) ClaimsValidator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		jwtInfo, err := GetJWTInfoFromContext(r.Context())
		if err != nil {
			next.ServeHTTP(w, r)
			return
		}

		claims, err := GetClaimsFromContext(r.Context())
		if err != nil {
			ctx := context.WithValue(r.Context(), ContextValidatorError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		err = claims.ValidateWithLeeway(jwt.Expected{
			Issuer: jwtInfo.Issuer,
		}, time.Second*30)

		if err != nil {
			ctx := context.WithValue(r.Context(), ContextValidatorError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}
		next.ServeHTTP(w, r)
	})
}

//ClaimsTerminator will read any errors generated by claims validator and if any are found end the request with a `401` error code, this was seperated out to allow for more efficent logging to your chosen logging platform.
func (mid *JWTMiddleware) ClaimsTerminator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		_, err := GetJWTInfoFromContext(r.Context())

		if err != nil {
			fmt.Println("JWT info was not in context: " + err.Error())
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		err, _ = GetValidatorErrorFromContext(r.Context())

		if err != nil {
			fmt.Println("Error was not nil: " + err.Error())
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		next.ServeHTTP(w, r)
	})
}
