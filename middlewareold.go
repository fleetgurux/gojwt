package gojwt

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/square/go-jose/v3"
	"github.com/square/go-jose/v3/jwt"
)

//JWTMiddlewareDep is used to mange JWT middleware
type JWTMiddlewareDep struct {
	JWKS        *jose.JSONWebKeySet
	Issuer      string
	EnableDebug bool
}

//NewJWTMiddlewareDep is used to greate a new JWTMiddlewareDep
func NewJWTMiddlewareDep(jwks *jose.JSONWebKeySet, issuer string) JWTMiddlewareDep {
	return JWTMiddlewareDep{
		JWKS:        jwks,
		Issuer:      issuer,
		EnableDebug: false,
	}
}

//NewJWTMiddlewareDepFromOpenID creates a new JWTMiddlewareDep from a OpenID definition
func NewJWTMiddlewareDepFromOpenID(baseURL string) (*JWTMiddlewareDep, error) {

	resp, err := http.Get(baseURL + "/.well-known/openid-configuration")
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}
	byteArr, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var bodyWellKnown OpenIDWellKnown
	err = json.Unmarshal(byteArr, &bodyWellKnown)
	if err != nil {
		return nil, err
	}

	keyset, err := GetJWKSetFromOpenIDURL(bodyWellKnown.JWKSURL)
	if err != nil {
		return nil, err
	}

	middleware := NewJWTMiddlewareDep(keyset, bodyWellKnown.Issuer)
	return &middleware, nil

}

//Verifier validtes every request to test if it matches the provided JWKs
func (mid *JWTMiddlewareDep) Verifier(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		bearerHeaderRaw := r.Header.Get("Authorization")
		if mid.EnableDebug {
			fmt.Println("Raw bearer token: " + bearerHeaderRaw)
		}
		bearerHeader := strings.Replace(bearerHeaderRaw, "Bearer ", "", -1)
		if mid.EnableDebug {
			fmt.Println("Cleaned bearer token: " + bearerHeader)
		}

		tok, err := jwt.ParseSigned(bearerHeader)

		if err != nil {
			if mid.EnableDebug {
				fmt.Println("Error getting claims: " + err.Error())
			}
			ctx := context.WithValue(r.Context(), ContextJWTError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		var claims *jwt.Claims
		for _, jwk := range mid.JWKS.Keys {
			err = tok.Claims(jwk, &claims)

			if err == nil {
				break
			}
		}

		if claims == nil {
			if mid.EnableDebug {
				fmt.Println("Error no claims found: " + err.Error())
			}
			ctx := context.WithValue(r.Context(), ContextJWTError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		ctx := context.WithValue(r.Context(), ContextJWTObject, tok)
		ctx = context.WithValue(r.Context(), ContextJWTClaims, claims)

		if mid.EnableDebug {
			fmt.Println("Verifier passed, calling next http")
		}
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

//ClaimsValidator will read claim values from context and validate, this includes ISS, EXP, NBF. if any validations fail a error will be logged under ContextValidatorError
func (mid *JWTMiddlewareDep) ClaimsValidator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		claims, err := GetClaimsFromContext(r.Context())
		if err != nil {
			if mid.EnableDebug {
				fmt.Println("Error getting claims: " + err.Error())
			}
			ctx := context.WithValue(r.Context(), ContextValidatorError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		err = claims.ValidateWithLeeway(jwt.Expected{
			Issuer: mid.Issuer,
		}, time.Second*30)

		if err != nil {
			if mid.EnableDebug {
				fmt.Println("Error invalid token: " + err.Error())
			}
			ctx := context.WithValue(r.Context(), ContextValidatorError, err)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}
		if mid.EnableDebug {
			fmt.Println("Claims validator passed")
		}
		next.ServeHTTP(w, r)
	})
}

//ClaimsTerminator will read any errors generated by claims validator and if any are found end the request with a `401` error code, this was seperated out to allow for more efficent logging to your chosen logging platform.
func (mid *JWTMiddlewareDep) ClaimsTerminator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		err, _ := GetValidatorErrorFromContext(r.Context())

		if err != nil {
			fmt.Println("Error was not nil: " + err.Error())
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		if mid.EnableDebug {
			fmt.Println("Claims terminator passed")
		}
		next.ServeHTTP(w, r)
	})
}
